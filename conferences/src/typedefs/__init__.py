# Code generated by jtd-codegen for Python v0.3.1

import re
from dataclasses import dataclass
from datetime import datetime, timedelta, timezone
from enum import Enum
from typing import Any, Dict, List, Optional, Type, Union, get_args, get_origin


class RootT(Enum):
    SUCHMANN_CONFERENCES_ROOT = "suchmann.conferences.root"
    @classmethod
    def from_json_data(cls, data: Any) -> 'RootT':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Root:
    conferences: 'List[Conference]'
    t: 'RootT'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Root':
        return cls(
            _from_json_data(List[Conference], data.get("conferences")),
            _from_json_data(RootT, data.get("t")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["conferences"] = _to_json_data(self.conferences)
        data["t"] = _to_json_data(self.t)
        return data

class ConferenceT(Enum):
    SUCHMANN_CONFERENCES_CONFERENCE = "suchmann.conferences.conference"
    @classmethod
    def from_json_data(cls, data: Any) -> 'ConferenceT':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Conference:
    h: 'str'
    i: 'ConferenceI'
    location: 'str'
    persons: 'List[Person]'
    rooms: 'List[Room]'
    sessions: 'List[Session]'
    sv_data: 'SvData'
    t: 'ConferenceT'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Conference':
        return cls(
            _from_json_data(str, data.get("h")),
            _from_json_data(ConferenceI, data.get("i")),
            _from_json_data(str, data.get("location")),
            _from_json_data(List[Person], data.get("persons")),
            _from_json_data(List[Room], data.get("rooms")),
            _from_json_data(List[Session], data.get("sessions")),
            _from_json_data(SvData, data.get("sv_data")),
            _from_json_data(ConferenceT, data.get("t")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["h"] = _to_json_data(self.h)
        data["i"] = _to_json_data(self.i)
        data["location"] = _to_json_data(self.location)
        data["persons"] = _to_json_data(self.persons)
        data["rooms"] = _to_json_data(self.rooms)
        data["sessions"] = _to_json_data(self.sessions)
        data["sv_data"] = _to_json_data(self.sv_data)
        data["t"] = _to_json_data(self.t)
        return data

@dataclass
class ConferenceI:
    name: 'str'
    year: 'int'

    @classmethod
    def from_json_data(cls, data: Any) -> 'ConferenceI':
        return cls(
            _from_json_data(str, data.get("name")),
            _from_json_data(int, data.get("year")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        data["year"] = _to_json_data(self.year)
        return data

class EventT(Enum):
    SUCHMANN_CONFERENCES_EVENT = "suchmann.conferences.event"
    @classmethod
    def from_json_data(cls, data: Any) -> 'EventT':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Event:
    h: 'str'
    i: 'EventI'
    order: 'int'
    person_hs: 'List[str]'
    t: 'EventT'
    url: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Event':
        return cls(
            _from_json_data(str, data.get("h")),
            _from_json_data(EventI, data.get("i")),
            _from_json_data(int, data.get("order")),
            _from_json_data(List[str], data.get("personHs")),
            _from_json_data(EventT, data.get("t")),
            _from_json_data(str, data.get("url")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["h"] = _to_json_data(self.h)
        data["i"] = _to_json_data(self.i)
        data["order"] = _to_json_data(self.order)
        data["personHs"] = _to_json_data(self.person_hs)
        data["t"] = _to_json_data(self.t)
        data["url"] = _to_json_data(self.url)
        return data

@dataclass
class EventI:
    session_h: 'str'
    title: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'EventI':
        return cls(
            _from_json_data(str, data.get("sessionH")),
            _from_json_data(str, data.get("title")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["sessionH"] = _to_json_data(self.session_h)
        data["title"] = _to_json_data(self.title)
        return data

@dataclass
class Node:
    t: 'NodeTypes'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Node':
        return cls(
            _from_json_data(NodeTypes, data.get("t")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["t"] = _to_json_data(self.t)
        return data

class NodeTypes(Enum):
    SUCHMANN_CONFERENCES_CONFERENCE = "suchmann.conferences.conference"
    SUCHMANN_CONFERENCES_EVENT = "suchmann.conferences.event"
    SUCHMANN_CONFERENCES_PERSON = "suchmann.conferences.person"
    SUCHMANN_CONFERENCES_ROOM = "suchmann.conferences.room"
    SUCHMANN_CONFERENCES_SESSION = "suchmann.conferences.session"
    SUCHMANN_CONFERENCES_SV_DATA = "suchmann.conferences.sv_data"
    SUCHMANN_CONFERENCES_SV_JOB = "suchmann.conferences.sv_job"
    @classmethod
    def from_json_data(cls, data: Any) -> 'NodeTypes':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

class PersonT(Enum):
    SUCHMANN_CONFERENCES_PERSON = "suchmann.conferences.person"
    @classmethod
    def from_json_data(cls, data: Any) -> 'PersonT':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Person:
    h: 'str'
    i: 'PersonI'
    t: 'PersonT'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Person':
        return cls(
            _from_json_data(str, data.get("h")),
            _from_json_data(PersonI, data.get("i")),
            _from_json_data(PersonT, data.get("t")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["h"] = _to_json_data(self.h)
        data["i"] = _to_json_data(self.i)
        data["t"] = _to_json_data(self.t)
        return data

@dataclass
class PersonI:
    disambiguator: 'str'
    first_name: 'str'
    last_name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'PersonI':
        return cls(
            _from_json_data(str, data.get("disambiguator")),
            _from_json_data(str, data.get("first_name")),
            _from_json_data(str, data.get("last_name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["disambiguator"] = _to_json_data(self.disambiguator)
        data["first_name"] = _to_json_data(self.first_name)
        data["last_name"] = _to_json_data(self.last_name)
        return data

class RoomT(Enum):
    SUCHMANN_CONFERENCES_ROOM = "suchmann.conferences.room"
    @classmethod
    def from_json_data(cls, data: Any) -> 'RoomT':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Room:
    h: 'str'
    i: 'RoomI'
    t: 'RoomT'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Room':
        return cls(
            _from_json_data(str, data.get("h")),
            _from_json_data(RoomI, data.get("i")),
            _from_json_data(RoomT, data.get("t")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["h"] = _to_json_data(self.h)
        data["i"] = _to_json_data(self.i)
        data["t"] = _to_json_data(self.t)
        return data

@dataclass
class RoomI:
    name: 'str'
    venue: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'RoomI':
        return cls(
            _from_json_data(str, data.get("name")),
            _from_json_data(str, data.get("venue")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        data["venue"] = _to_json_data(self.venue)
        return data

class SessionT(Enum):
    SUCHMANN_CONFERENCES_SESSION = "suchmann.conferences.session"
    @classmethod
    def from_json_data(cls, data: Any) -> 'SessionT':
        return cls(data)

    def to_json_data(self) -> Any:
        return self.value

@dataclass
class Session:
    date: 'str'
    end: 'str'
    events: 'List[Event]'
    h: 'str'
    i: 'SessionI'
    room_h: 'str'
    start: 'str'
    t: 'SessionT'

    @classmethod
    def from_json_data(cls, data: Any) -> 'Session':
        return cls(
            _from_json_data(str, data.get("date")),
            _from_json_data(str, data.get("end")),
            _from_json_data(List[Event], data.get("events")),
            _from_json_data(str, data.get("h")),
            _from_json_data(SessionI, data.get("i")),
            _from_json_data(str, data.get("roomH")),
            _from_json_data(str, data.get("start")),
            _from_json_data(SessionT, data.get("t")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["date"] = _to_json_data(self.date)
        data["end"] = _to_json_data(self.end)
        data["events"] = _to_json_data(self.events)
        data["h"] = _to_json_data(self.h)
        data["i"] = _to_json_data(self.i)
        data["roomH"] = _to_json_data(self.room_h)
        data["start"] = _to_json_data(self.start)
        data["t"] = _to_json_data(self.t)
        return data

@dataclass
class SessionI:
    name: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SessionI':
        return cls(
            _from_json_data(str, data.get("name")),
        )

    def to_json_data(self) -> Any:
        data: Dict[str, Any] = {}
        data["name"] = _to_json_data(self.name)
        return data

@dataclass
class SvData:
    am_i_sv: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvData':
        variants: Dict[str, Type[SvData]] = {
            "no": SvDataNo,
            "yes": SvDataYes,
        }

        return variants[data["am_i_sv"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class SvDataNo(SvData):

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvDataNo':
        return cls(
            "no",
        )

    def to_json_data(self) -> Any:
        data = { "am_i_sv": "no" }
        return data

@dataclass
class SvDataYes(SvData):
    my_sv_jobs: 'List[SvJob]'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvDataYes':
        return cls(
            "yes",
            _from_json_data(List[SvJob], data.get("my_sv_jobs")),
        )

    def to_json_data(self) -> Any:
        data = { "am_i_sv": "yes" }
        data["my_sv_jobs"] = _to_json_data(self.my_sv_jobs)
        return data

@dataclass
class SvJob:
    type: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvJob':
        variants: Dict[str, Type[SvJob]] = {
            "quick_response": SvJobQuickResponse,
            "registration": SvJobRegistration,
            "session": SvJobSession,
        }

        return variants[data["type"]].from_json_data(data)

    def to_json_data(self) -> Any:
        pass

@dataclass
class SvJobQuickResponse(SvJob):
    date: 'str'
    end: 'str'
    start: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvJobQuickResponse':
        return cls(
            "quick_response",
            _from_json_data(str, data.get("date")),
            _from_json_data(str, data.get("end")),
            _from_json_data(str, data.get("start")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "quick_response" }
        data["date"] = _to_json_data(self.date)
        data["end"] = _to_json_data(self.end)
        data["start"] = _to_json_data(self.start)
        return data

@dataclass
class SvJobRegistration(SvJob):
    date: 'str'
    end: 'str'
    start: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvJobRegistration':
        return cls(
            "registration",
            _from_json_data(str, data.get("date")),
            _from_json_data(str, data.get("end")),
            _from_json_data(str, data.get("start")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "registration" }
        data["date"] = _to_json_data(self.date)
        data["end"] = _to_json_data(self.end)
        data["start"] = _to_json_data(self.start)
        return data

@dataclass
class SvJobSession(SvJob):
    note: 'str'
    session_h: 'str'

    @classmethod
    def from_json_data(cls, data: Any) -> 'SvJobSession':
        return cls(
            "session",
            _from_json_data(str, data.get("note")),
            _from_json_data(str, data.get("sessionH")),
        )

    def to_json_data(self) -> Any:
        data = { "type": "session" }
        data["note"] = _to_json_data(self.note)
        data["sessionH"] = _to_json_data(self.session_h)
        return data

def _from_json_data(cls: Any, data: Any) -> Any:
    if data is None or cls in [bool, int, float, str, object] or cls is Any:
        return data
    if cls is datetime:
        return _parse_rfc3339(data)
    if get_origin(cls) is Union:
        return _from_json_data(get_args(cls)[0], data)
    if get_origin(cls) is list:
        return [_from_json_data(get_args(cls)[0], d) for d in data]
    if get_origin(cls) is dict:
        return { k: _from_json_data(get_args(cls)[1], v) for k, v in data.items() }
    return cls.from_json_data(data)

def _to_json_data(data: Any) -> Any:
    if data is None or type(data) in [bool, int, float, str, object]:
        return data
    if type(data) is datetime:
        return data.isoformat()
    if type(data) is list:
        return [_to_json_data(d) for d in data]
    if type(data) is dict:
        return { k: _to_json_data(v) for k, v in data.items() }
    return data.to_json_data()

def _parse_rfc3339(s: str) -> datetime:
    datetime_re = '^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(\.\d+)?([zZ]|((\+|-)(\d{2}):(\d{2})))$'
    match = re.match(datetime_re, s)
    if not match:
        raise ValueError('Invalid RFC3339 date/time', s)

    (year, month, day, hour, minute, second, frac_seconds, offset,
     *tz) = match.groups()

    frac_seconds_parsed = None
    if frac_seconds:
        frac_seconds_parsed = int(float(frac_seconds) * 1_000_000)
    else:
        frac_seconds_parsed = 0

    tzinfo = None
    if offset == 'Z':
        tzinfo = timezone.utc
    else:
        hours = int(tz[2])
        minutes = int(tz[3])
        sign = 1 if tz[1] == '+' else -1

        if minutes not in range(60):
            raise ValueError('minute offset must be in 0..59')

        tzinfo = timezone(timedelta(minutes=sign * (60 * hours + minutes)))

    second_parsed = int(second)
    if second_parsed == 60:
        second_parsed = 59

    return datetime(int(year), int(month), int(day), int(hour), int(minute),
                    second_parsed, frac_seconds_parsed, tzinfo)            
